%\VignetteIndexEntry{Quality assessment with arrayQualityMetrics}
%\VignetteDepends{CCl4, ALLMLL,vsn}
%\VignettePackage{arrayQualityMetrics}

\documentclass[11pt]{article}

\usepackage{times}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage[pdftex,linktocpage]{hyperref}

\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}

\SweaveOpts{keep.source=TRUE,eps=FALSE,include=FALSE,width=4,height=4.5}

\begin{document}

\title{Microarray quality assessment with arrayQualityMetrics}
\author{Audrey Kauffmann, Wolfgang Huber}
\maketitle
\tableofcontents
\pagebreak

\section*{Introduction}

The \Rpackage{arrayQualityMetrics} package produces, through a single
function call, a comprehensive HTML report of \emph{quality metrics}
about the data set.  The quality metrics are mainly on the
\emph{per-array} level, i.\,e.\ they can be used to assess the
relative quality of different arrays within a data set. Some of the
metrics can also be used to diagnose batch effects, and thus the
quality of the overall data set.

The report can be extended to contain further diagnostics through
additional arguments, and we will see examples below.

The aim of the \Rpackage{arrayQualityMetrics} package is to produce
information that is relevant for your decision making - not, to make
the decision. It will often be applied to two, somewhat distinct, use
cases: (i) assessing quality of a ``raw'' data set, in order to get
feedback on the experimental procedures that produced the data; (ii)
assessing quality of a normalised data set, in order to decide whether
and how to use the data set (or subsets of arrays in it) for subsequent
data analysis.

Each type of microarray data (one colour, two colour, Affymetrix,
Illumina...) is represented by a class of object in
Bioconductor. However, the interface to the function
\Rfunction{arrayQualityMetrics} is the same for all of them. Please
consult its manual page for its argments.

When the function \Rfunction{arrayQualityMetrics} is finished, a
report named \texttt{QMreport.html} is produced in the subdirectory
specified by the function's \texttt{outdir} argument.
The report contains a series of plots explained by text.
For the web presentation, the plots are produced as bitmaps (\texttt{.png}).
They are also linked to \texttt{.pdf} files in order to
provide high resolution images e.\,g.\ for publication. 

In the case of \Rclass{AffyBatch} input, some Affymetrix specific
plots are added to the standard report. As explained in the Section
\ref{ext}, other plots can be added to the standard report if some
specific columns are present in the input object.

The function \Rfunction{arrayQualityMetrics} also produces an R object
(essentially, a very big list) with all the information contained in
the report, and this object can be used by downstream tools for
programmatic analysis of the report.

\section{Minimal use}
%
<<options,echo=FALSE>>=
options(error = recover)
@
%

\subsection{Example on Affymetrix data}
If you are working with Affymetrix chips, an \Rclass{AffyBatch} object
is the most appropriate to import your raw data into Bioconductor.
Starting from CEL files, this is typically done using the function
\Rfunction{ReadAffy} from the \Rpackage{affy} package\footnote{For 
more information on how to produce an \Rclass{AffyBatch} from your data, please see
the documentation of the \Rpackage{affy} package.}.  Here, we use the
dataset \emph{MLL.A}, an object of class \Rclass{AffyBatch} 
provided in the data package \Rpackage{ALLMLL}.
%
<<DataLoading>>=
library("ALLMLL")
data("MLL.A")
@ 

Now that the data are loaded, we can call
\Rfunction{arrayQualityMetrics}\footnote{For this vignette, in order to save
computation time, we only call the function on the first 5 arrays; in
your own application, you can call it on the complete data object.}. 

%
<<AffyBatchQM,results=hide>>=
library("arrayQualityMetrics")
arrayQualityMetrics(expressionset = MLL.A[, 1:5],
                    outdir = "MLL",
                    force = TRUE,
                    do.logtransform = TRUE)
@
%

This is the simplest way of calling the function. We give a name to
the directory (\texttt{outdir}) and we overwrite the possibly existing
files of this directory (\texttt{force}). Finally, we set
\texttt{do.logtransform} to logarithm transform the intensities.

\subsection{Example with one colour arrays}

If you are working on one colour non Affymetrix chips, you can load
your data into Bioconductor as an \Rclass{ExpressionSet}
object. Please see the documentation of the \Rpackage{Biobase} package
on how to do so. Here, for demonstration, we use the
\Rclass{ExpressionSet} produced from \emph{MLL.A} by calling the RMA
algorithm.  It contains one value (expression estimate) for each gene
for each array.

%
<<Normalisation,results=hide>>=
rMLL = rma(MLL.A)
@ 
%

We can then call \Rfunction{arrayQualityMetrics}.

%
<<ExpressionSet,results=hide>>=
arrayQualityMetrics(expressionset = rMLL,
                    outdir = "Report for rMLL",
                    force = TRUE)
@
%
We do not need to set \texttt{do.logtransform} as after
\Rfunction{rma} the data are already logarithm transformed.

\subsection{Example with two colour arrays}

If you are working on two colour chips, you can create an
\Rclass{NChannelSet} to contain your data. The documentation of the
\Rpackage{Biobase} package gives instructions on how to build a
\Rclass{NChannelSet}.  Here, for demonstration, we use the data set
\Robject{CCl4} from the data package \Rpackage{CCl4} and normalize it
using the variance stabilization method available in the package
\Rpackage{vsn}.

%
<<NChannelSet,results=hide>>=
library("vsn")
library("CCl4")
data("CCl4")
nCCl4 = justvsn(CCl4, subsample = 2000)
arrayQualityMetrics(expressionset = nCCl4,
                    outdir = "Report for nCCl4",
                    force = TRUE)
@
%

\subsection{Other type of objects}

Through the previous examples, you have seen that
\Rfunction{arrayQualityMetrics} is used the same way on different
types of object.  If you have Illumina bead arrays, you can build a
\Rclass{BeadLevelList}, which is explained in the \Rpackage{beadarray}
package, and run \Rfunction{arrayQualityMetrics}.  It is also possible
to use \Rfunction{arrayQualityMetrics} on objects of the classes \Rclass{RGList},
\Rclass{MAList}, \Rclass{marrayRaw} and \Rclass{marrayNorm}. More
information about the \Rclass{RGList} and \Rclass{MAList} classes is
given in the package \Rpackage{limma}. The objects \Rclass{marrayRaw}
and \Rclass{marrayNorm} are explained in the vignette of the package
\Rpackage{marray}.

\section{Playing with the arguments}

\subsection{Factor of interest}

A useful feature of \Rfunction{arrayQualityMetrics} is the possibility
to show the results in the context of an experimental factor of
interest, i.\,e.\ a categorical variable associated with the arrays
such as \emph{hybridisation date}, \emph{treatment level} or
\emph{replicate number}. Specifying a factor does not change anything
how the quality metrics are computed. By setting the argument
\Rfunction{intgroup} to contain the names of one or multiple columns
of the data object's \Rclass{phenoData} slot\footnote{This is where
  Bioconductor objects store array annotation}, a bar on the side of
the heatmap with colours representing the respective factors is added.
Similarly, the colours of the boxplots and density plots reflect the
levels of the first of the factors named by \Rfunction{intgroup}.

We use the \emph{rMLL} example again, and create artificial columns

%
<<intgroup1>>=
pData(rMLL)$fact1 = rep(letters[1:4], times = 5)
pData(rMLL)$fact2 = rep(letters[1:4], each = 5)
@ 
<<intgroup2, results=hide>>=
arrayQualityMetrics(expressionset = rMLL,
                    outdir = "rMLL-facts",
                    force = TRUE,
                    intgroup = c("fact1","fact2"))
@
%

\section{Extended use}
\label{ext}
Some of the quality metrics provided by the package are performed
using specific information about the features of the arrays.  To have
more quality metrics in the report, you can add the needed information
in your input object.  We can use the \emph{nCCl4} example again.

\subsection{Spatial layout of the array}

To plot the spatial distributions of the intensities of the arrays,
\Rfunction{arrayQualityMetrics} needs the coordinates of the spots on
the chip. In the case of \Rclass{AffyBatch} or \Rclass{BeadLevelList},
this is automatically done without further information needed. For the
other types of objects, two columns corresponding to the row and
column numbers of the features are required in the
\Rclass{featureData}. These columns should be named "X" for rows and
"Y" for columns. If the arrays are split into blocks, then the
function \Rfunction{addXYfromGAL} (please check its manual page for
details) should be executed prior to \Rfunction{arrayQualityMetrics}
to convert the rows and columns of the blocks in absolute "X" and "Y"
on the array. In the example of the data set \emph{CCl4}, the
coordinates of the spots are in the columns named "Row" and "Column"
of the featureData (the slot of the object containing the annotation
of the probes). We thus need to copy this information in columns named
"X" and "Y" respectively, so that these coordinates are taken into
account and the spatial distribution of the intensities can be drawn.

%
<<XYcoordinates>>=
featureData(nCCl4)$X = featureData(nCCl4)$Row
featureData(nCCl4)$Y = featureData(nCCl4)$Column
@
%

\subsection{Mapping of the reporters}

The report can also include an assessment of the effect of the target
mapping of the reporters. Thus a \Rclass{featureData} column named
\texttt{hasTarget} should include a logical \texttt{TRUE} if the
reporter matches for a coding mRNA and \texttt{FALSE} if not. In the
\emph{CCl4} example, many of the feature names are RefSeq
identifiers. Thus, we test the feature names whether they with "NM",
and assume that these corresponding to coding mRNA. "hasTarget" can be
derived from this, in the following way:

%
<<hasTarget>>=
featureData(nCCl4)$hasTarget = (regexpr("^NM", featureData(nCCl4)$Name) > 0)
@
%
This command line produces \texttt{TRUE} if the probe name starts with
"NM" and \texttt{FALSE} if it does not.

\subsection{GC content of the reporters}

If the GC content of the reporters is known, then it is possible to include it as percentages in the
\Rclass{featureData} of the \Rclass{NChannelSet} under the column name "GC". Then a study of
the GC content effect on intensities of the arrays can be performed. In the \emph{CCl4} example we do not have this information. However, the process would be very similar to what is done with the "hasTarget" column.


\subsection{RNA quality - RIN number}

As seen before, we can make use of a factor of interest. In the case
of the \emph{CCl4} dataset, the RNA hybridized to the arrays can be of
good, medium or poor quality accordingly to its RIN number (see
\emph{CCl4} vignette). We can read the sample information of
\emph{CCl4}, there are 4 RIN values: 2.5, 5, 9 and 9.7, with 9 always
corresponding to the reference. As the RIN number is given per dye, we
need to create a variable which will be "Good" when one of the two
dyes RIN is 9.7, "Medium" when it is 5 and "Poor" when it is 2.5. In
this example, we will copy this variable in a column "RNAintegrity" of
the \Rclass{phenoData}. We will set the argument 'intgroup' with this
name when calling the function \Rfunction{arrayQualityMetrics}.

%
<<Covariate>>=
datapath = system.file("extdata", package="CCl4")
p = read.AnnotatedDataFrame("samplesInfo.txt", path=datapath)
cond = paste(p$RIN.Cy3,p$RIN.Cy5,sep="/")
poor = grep(cond,pattern="2.5")
medium = grep(cond,pattern="^5/|/5")
good = grep(cond,pattern="9.7")
cov = rep(0, length = nrow(p))
cov[good] = "Good"
cov[medium] = "Medium"
cov[poor] = "Poor"
phenoData(nCCl4)$RNAintegrity = cov
@
%
<<NChannelSet,results=hide>>=
arrayQualityMetrics(expressionset = nCCl4,
                    outdir = "CCl4-RIN",
                    force = TRUE,
                    intgroup = "RNAintegrity")
@
%

A report named \texttt{QMreport.html} is produced in the subdirectory
\texttt{CCl4-RIN}. Boxplots and density plots are represented with
colours depending on the "RNAintegrity" value, and a side bar is drawn
next to the heatmap and coloured according to this factor as well.

\subsection*{Session Info}
%
<<pkgs, results=tex>>=
toLatex(sessionInfo())
@
%

\end{document}
