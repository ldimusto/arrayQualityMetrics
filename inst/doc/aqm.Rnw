%\VignetteIndexEntry{Customizing arrayQualityMetrics reports}
%\VignetteDepends{}

\documentclass[11pt]{article}

\usepackage{times}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage[pdftex,linktocpage]{hyperref}

\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}

\SweaveOpts{keep.source=TRUE,eps=FALSE,include=FALSE,width=4,height=4.5}

\begin{document}

\title{Customizing arrayQualityMetrics reports}
\author{Audrey Kauffmann}
\maketitle
\tableofcontents

\section*{Introduction}
In the other vignette of this package, \emph{Microarray quality assessment with
  arrayQualityMetrics}, you can learn how to use the
\Rfunction{arrayQualityMetrics} function to create an array quality report. If
you are new to this package, then that is what you should consult.

This vignette addresses a more advanced topic: how to customize the
report by selecting specific modules and sections, or adding your own
ones.

\paragraph{Sections and modules:} In the documentation of this package, we refer
to a \emph{module} as a self-contained element of a report, which usually consists of a 
figure, some explanatory text, and potentially a set of flags for the arrays in
datasets that classifies some of them as outliers. We refer to a \emph{section} as a
collection of one or more modules that are thematically related.


\section{Data preparation}

Some of the computations that are needed for the modules are common
between several modules, and thus we perform them once,
beforehand. These functions are called \Rfunction{prepdata} and
\Rfunction{prepaffy}, and we refer to their manual page for 
details.

\section{Module generating functions}
The package contains a variety of functions that compute modules, and they are
listed on a manual page which you can access by typing:
<<eval=FALSE>>=
?aqm.boxplot
@ 


\section{Rendering of the output in a report}
The functions available to render the output:
\begin{itemize}
\item \Rfunction{aqm.plot}: allows to plot in a R device any object of class \Rclass{aqmobj.xxx} which contains a slot names \texttt{"plot"}.
\item \Rfunction{aqm.writereport}: writes a html report containing the input metrics.

\end{itemize}

\section{Example of a customized report}

We will create a report with only 2 quality metrics, the boxplots and the density plots.
First we need to load the needed packages and the data.

<<echo=FALSE,results=hide>>=
options(error=recover)
@ 

<<loading>>=
library("arrayQualityMetrics")
library("CCl4")
library("vsn")
data("CCl4")
nCCl4 = justvsn(CCl4, subsample=2200)
@

We need to create an object \Rclass{aqmobj.prepdata} to be able to call the quality metrics functions.
<<DataPreparation>>=
dataprep = prepdata(expressionset = nCCl4, intgroup = c(), do.logtransform = FALSE, usesvg = capabilities()["cairo"])
@ 

We compute the boxplot and density plots metrics and then create a list containing both of them.
<<metrics>>=
bo = aqm.boxplot(dataprep)
de = aqm.density(dataprep)
qm = list("Boxplot" = bo, "Density" = de)
@ 

We now can write a small report containing those two metrics.
<<shortReport>>=
outdir = tempdir()
aqm.writereport(modules = qm, reporttitle = "My example", outdir = ".", arrayTable = pData(CCl4))
outdir
@ 

\section{How to add your own metrics}
Here is an example of a function, studying the GC content effects, that can be added to the report.

We are writing the function \Rfunction{aqm.GC} to compute boxplots grouped by GC content of the probes.

\subsection{Creating the aqm function and aqmobj class}
The first step is to create a class for the output object. 

<<aqmobj.GC>>=
 setClass("aqmobj.GC", representation(plot="list",
                                     section="character",
                                     title="character",
                                     legend="character",
                                     shape="character"))
@ 
Then, we can write the function. For the example, we will only make it work for \Rclass{NChannelSet}.
'GC' refers to the GC content whereas 'gc' stands for 'green channel' in the data set (with 'rc' being 'red channel' and 'dat' the log(ratio)).

<<aqm.GC>>=
setGeneric("aqm.GC",
           function(expressionset, dataprep, ...)
           standardGeneric("aqm.GC"))
        
setMethod("aqm.GC",signature(expressionset = "NChannelSet"), 
          function(expressionset, dataprep, ...) {
  fac = round(featureData(expressionset)$GC,-1)      
  df = data.frame(rep(fac, ncol(dataprep$dat)), as.numeric(dataprep$rc), 
    as.numeric(dataprep$gc), as.numeric(dataprep$dat))
  colnames(df) = c("GC","rc","gc","dat")
  
  box1 = bwplot(rc ~ GC, data = df, pch = "|", do.out = FALSE,
    box.ratio = 2, xlab = "Red Intensity", ylab = "GC content", 
    horizontal = FALSE, fill="red")
  box2 = bwplot(gc ~ GC, data = df, pch = "|", do.out = FALSE, 
    box.ratio = 2, xlab = "Green Intensity", ylab = "", 
    horizontal = FALSE, fill="green")
  box3 = bwplot(dat ~ GC, data = df, pch = "|", do.out = FALSE, 
    box.ratio = 2, xlab = "Log(ratio)", ylab = "", 
    horizontal = FALSE, fill="blue")
              
  plotGC = list("box1" =  box1, "box2" = box2, "box3" = box3)
  
  title = "GC content effect"
  
  section = "Probe stratification"
  
  legend = "<b>Figure <!-- FIG --></b> shows the boxplots of the log<sub>2</sub> 
intensities grouped by the percentage of cytosines (C) and guanines (G) among the 
nucleotides in each probe. Cytosine and guanine are able to form three hydrogen bonds, 
while adenine (A) and thymine (T) only form two, hence oligonucleotides with a higher 
proportion of C and G can form more stable hybridization bindings. 
This tends to result in higher intensities measured on the array, regardless of the 
abundance of target molecules."
              
  out = list("plot" = plotGC, "section" = section, "title" = title, 
             "legend" = legend, "shape" = "rect")
  class(out) = "aqmobj.GC"
  return(out)   
})      
@ 

\subsection{Creating a method for aqm.plot}
Once the \Rfunction{aqm.GC} is written, we need to write a \Rfunction{aqm.plot} method for it, to be able to draw the plot with the desired settings.

%
<<aqm.plot.aqm.GC, eval=FALSE>>=
setMethod("aqm.plot",signature(obj = "aqmobj.GC"), function(obj){
  print(obj$plot$box1, split = c(1,1,3,1), newpage = FALSE)
  print(obj$plot$box2, split = c(2,1,3,1), newpage = FALSE)
  print(obj$plot$box3, split = c(3,1,3,1), newpage = FALSE)
})
@ 

\subsection{Example of application}
We can call the function on an example dataset. We first create a column "GC" in the \Rclass{featureData} of the object \Robject{nCCl4}.

<<createGC, eval=FALSE>>=
datapath = system.file("extdata", package="CCl4")
seq = read.AnnotatedDataFrame("013162_D_SequenceList_20060815.txt", path=datapath)
if(any(duplicated(featureNames(seq))))
  cat("IDs of the sequence file are not unique \n")
bc = alphabetFrequency(DNAStringSet(seq$Sequence), baseOnly=TRUE)
GC = ((bc[,"C"]+bc[,"G"])/rowSums(bc))*100
mt = match(featureNames(seq), fData(nCCl4)$ID)
stopifnot(!any(is.na(mt)))
fData(nCCl4)$GC = NA_real_
fData(nCCl4)$GC[mt] = GC
@ 

Now, we can call the \Rfunction{aqm.GC} function and create a small html report with its output.
<<aqm.plot.aqm.GC, eval=FALSE>>=
library("lattice")
testgc = aqm.GC(nCCl4,dataprep)
aqm.plot(testgc)
aqm.writereport("GC Study", nCCl4, testgc)
@ 

\subsection*{Session Info}
%
<<pkgs, results=tex>>=
toLatex(sessionInfo())
@
%

\end{document}
