%\VignetteIndexEntry{arrayQualityMetrics modules}
%\VignetteDepends{}

\documentclass[11pt]{article}

\usepackage{times}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage[pdftex,linktocpage]{hyperref}

\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}

\SweaveOpts{keep.source=TRUE,eps=FALSE,include=FALSE,width=4,height=4.5}

\begin{document}

\title{Calling individual modules of arrayQualityMetrics}
\author{Audrey Kauffmann}
\maketitle
\tableofcontents
\pagebreak

\section*{Introduction}
In the vignette arrayQualityMetrics.pdf, you can learn how to use the arrayQualityMetrics function to create a full report. In this vignette, we show how to only run one or several of the metrics and how to add your own modules to customize the report.
%
<<options,echo=FALSE>>=
if (Sys.info()["sysname"] == "Darwin")
  options(bitmapType = "cairo")
@
%

\section{Functions to format the data for aqm functions usage}

There are two functions to prepare the data. They compute intermediate results that are then processed by the \Rfunction{aqm.xxx} functions. They are greedy and slow but as they only are ran once, it allows a better computational efficiency.

\begin{itemize}
\item \Rfunction{aqm.prepdata}: generates a \Rclass{aqmobj.prepdata} object which can be the input of all the \Rfunction{aqm.xxx} functions.
\item \Rfunction{aqm.prepaffy}: generates a \Rclass{aqmobj.prepaffy} object which is the input for some of the Affymetrix specific functions.
\end{itemize}

\section{Metrics available in the report}
\subsection{Functions with outlier detection}
The functions to compute quality metrics are the following:
\begin{itemize}
\item \Rfunction{aqm.maplot}: computes the M versus A plot and generates an object \Rclass{aqmobj.ma}.
\item \Rfunction{aqm.spatial}: computes the spatial distribution of the ranks for the foreground intensities and generates an object \Rclass{aqmobj.spatial}.
\item \Rfunction{aqm.boxplot}: computes the boxplots of the intensities and generates an object \Rclass{aqmobj.box}.
\item \Rfunction{aqm.heatmap}: computes the heatmap of the between-array distances and generates an object \Rclass{aqmobj.heatmap}.
\end{itemize}

The output objects contain the plot, the legend, the title, the name of the section it belongs to in the report, the scores per array that are used to perform the outlier detection and the array names that are detected as outliers.

\subsection{Functions without outlier detection}
The following functions also compute quality metrics: 
\begin{itemize}
\item \Rfunction{aqm.spatialbg}: represents the spatial distribution of the rank background intensities and generates an object \Rclass{aqmobj.spatialbg}.
\item \Rfunction{aqm.density}: performs the density plots of the intensities and generates an object \Rclass{aqmobj.dens}.
\item \Rfunction{aqm.meansd}: compares the mean of the intensities to their standard deviation and generates an object \Rclass{aqmobj.msd}.
\item \Rfunction{aqm.probesmap}: draws density plots of two classes of probes as annotated in the "hasTarget" column of the \Rclass{featureData} and generates an object \Rclass{aqmobj.probesmap}.
\end{itemize}

The output objects contain the plot, the legend, the title and the name of the section it belongs to in the report. No outlier detection is computed for those metrics.

\subsection{Functions for Affymetrix data}
The functions available for Affymetrix datasets are:
\begin{itemize}
\item \Rfunction{aqm.rnadeg}: is used to represent the RNA degradation plot and creates the object \Rclass{aqmobj.rnadeg}.
\item \Rfunction{aqm.rle}: performs Relative Log Expression boxplots and formats the output with outliers in the \Rclass{aqmobj.rle} object.
\item \Rfunction{aqm.nuse}: computes Normalised Unscaled Standard Error boxplots and outlier detection on it and formats the output as an object \Rclass{aqmobj.nuse}.
\item \Rfunction{aqm.qcstats}: draws the QCStats plot from the \Rpackage{simpleaffy} package and creates an object of class \Rclass{aqmobj.qcs}.
\item \Rfunction{aqm.pmmm}:  draws density plots of the perfect match probes and the mismatch probes and generates an object\Rclass{aqmobj.pmmm}.
\end{itemize}

\section{Rendering of the output in a report}
The functions available to render the output:
\begin{itemize}
\item \Rfunction{aqm.plot}: allows to plot in a R device any object of class \Rclass{aqmobj.xxx} which contains a slot names \texttt{"plot"}.
\item \Rfunction{aqm.writereport}: writes a html report containing the input metrics.

\end{itemize}

\section{Example of a customized report}

We will create a report with only 2 quality metrics, the boxplots and the density plots.
First we need to load the needed packages and the data.

<<loading>>=
library("arrayQualityMetrics")
library("CCl4")
library("vsn")
data(CCl4)
nCCl4 = justvsn(CCl4, subsample=2200)
@

We need to create an object \Rclass{aqmobj.prepdata} to be able to call the quality metrics functions.
<<DataPreparation>>=
dataprep = aqm.prepdata(expressionset = nCCl4, do.logtransform = FALSE)
@ 

We compute the boxplot and density plots metrics and then create a list containing both of them.
<<metrics>>=
bo = aqm.boxplot(dataprep)
de = aqm.density(dataprep)
qm = list("Boxplot" = bo, "Density" = de)
@ 

We now can write a small report containing those two metrics.
<<shortReport>>=
aqm.writereport(name = "Customized example", expressionset = nCCl4, obj = qm)
@ 

\section{How to add your own metrics}
Here is an example of a function, studying the GC content effects, that can be added to the report.

We are writing the function \Rfunction{aqm.GC} to compute boxplots grouped by GC content of the probes.

\subsection{Creating the aqm function and aqmobj class}
The first step is to create a class for the output object. 

<<aqmobj.GC>>=
 setClass("aqmobj.GC", representation(plot="list",
                                     section="character",
                                     title="character",
                                     legend="character",
                                     shape="character"))
@ 
Then, we can write the function. For the example, we will only make it work for \Rclass{NChannelSet}.
'GC' refers to the GC content whereas 'gc' stands for 'green channel' in the data set (with 'rc' being 'red channel' and 'dat' the log(ratio)).

<<aqm.GC>>=
setGeneric("aqm.GC",
           function(expressionset, dataprep, ...)
           standardGeneric("aqm.GC"))
        
setMethod("aqm.GC",signature(expressionset = "NChannelSet"), 
          function(expressionset, dataprep, ...) {
  fac = round(featureData(expressionset)$GC,-1)      
  df = data.frame(rep(fac, ncol(dataprep$dat)), as.numeric(dataprep$rc), 
    as.numeric(dataprep$gc), as.numeric(dataprep$dat))
  colnames(df) = c("GC","rc","gc","dat")
  
  box1 = bwplot(rc ~ GC, data = df, pch = "|", do.out = FALSE,
    box.ratio = 2, xlab = "Red Intensity", ylab = "GC content", 
    horizontal = FALSE, fill="red")
  box2 = bwplot(gc ~ GC, data = df, pch = "|", do.out = FALSE, 
    box.ratio = 2, xlab = "Green Intensity", ylab = "", 
    horizontal = FALSE, fill="green")
  box3 = bwplot(dat ~ GC, data = df, pch = "|", do.out = FALSE, 
    box.ratio = 2, xlab = "Log(ratio)", ylab = "", 
    horizontal = FALSE, fill="blue")
              
  plotGC = list("box1" =  box1, "box2" = box2, "box3" = box3)
  
  title = "GC content effect"
  
  section = "Probe stratification"
  
  legend = "<b>Figure <!-- FIG --></b> shows the boxplots of the log<sub>2</sub> 
intensities grouped by the percentage of cytosines (C) and guanines (G) among the 
nucleotides in each probe. Cytosine and guanine are able to form three hydrogen bonds, 
while adenine (A) and thymine (T) only form two, hence oligonucleotides with a higher 
proportion of C and G can form more stable hybridization bindings. 
This tends to result in higher intensities measured on the array, regardless of the 
abundance of target molecules."
              
  out = list("plot" = plotGC, "section" = section, "title" = title, 
             "legend" = legend, "shape" = "rect")
  class(out) = "aqmobj.GC"
  return(out)   
})      
@ 

\subsection{Creating a method for aqm.plot}
Once the \Rfunction{aqm.gc} is written, we need to write a \Rfunction{aqm.plot} method for it, to be able to draw the plot with the desired settings.

%
<<aqm.plot.aqm.gc>>=
setMethod("aqm.plot",signature(obj = "aqmobj.gc"), function(obj){
  print(obj$plot$box1, split = c(1,1,3,1), newpage = FALSE)
  print(obj$plot$box2, split = c(2,1,3,1), newpage = FALSE)
  print(obj$plot$box3, split = c(3,1,3,1), newpage = FALSE)
})
@ 

\subsection{Example of application}
We can call the function on an example dataset. We first create a column "GC" in the \Rclass{featureData} of the object \Robject{nCCl4}.

<<createGC>>=
datapath = system.file("extdata", package="CCl4")
seq = read.AnnotatedDataFrame("013162_D_SequenceList_20060815.txt", path=datapath)
if(any(duplicated(featureNames(seq))))
  cat("IDs of the sequence file are not unique \n")
bc = basecontent(seq$Sequence)
GC = ((bc[,"C"]+bc[,"G"])/rowSums(bc))*100
mt = match(featureNames(seq), fData(nCCl4)$ID)
stopifnot(!any(is.na(mt)))
fData(nCCl4)$GC = NA_real_
fData(nCCl4)$GC[mt] = GC
@ 

Now, we can call the \Rfunction{aqm.GC} function and create a small html report with its output.
<<aqm.plot.aqm.gc>>=
library("lattice")
dataprep = aqm.prepdata(nCCl4, FALSE)
testgc = aqm.gc(nCCl4,dataprep)
aqm.plot(testgc)
aqm.writereport("GC Study", nCCl4, testgc)
@ 

\subsection*{Session Info}
%
<<pkgs, results=tex>>=
toLatex(sessionInfo())
@
%

\end{document}
